--generated by V2 synthesiser
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;

entity ssegDriver is port (
	clk : in std_logic;
	rst : in std_logic;
	invert : in std_logic;
	cathode_p : out std_logic_vector(7 downto 0);
	digit1_p : in std_logic_vector(3 downto 0);
	anode_p : out std_logic_vector(7 downto 0);
	digit2_p : in std_logic_vector(3 downto 0);
	digit3_p : in std_logic_vector(3 downto 0);
	digit4_p : in std_logic_vector(3 downto 0);
	digit5_p : in std_logic_vector(3 downto 0);
	digit6_p : in std_logic_vector(3 downto 0);
	digit7_p : in std_logic_vector(3 downto 0);
	digit8_p : in std_logic_vector(3 downto 0)
); end ssegDriver;

------------------------------------------------

architecture behavioural of ssegDriver is

	signal digit_reg : std_logic_vector(31 downto 0);
	signal anode_reg : std_logic_vector(7 downto 0);
	signal digitout_reg : std_logic_vector(3 downto 0);
	signal digit_sel : std_logic_vector(2 downto 0);
	signal next_sel : std_logic_vector(2 downto 0);
	
	begin
		
		--Clock and set state machine
		process (clk, rst) 
			begin
				if (rst = '1') then
					digit_reg <= "00000000000000000000000000000000";
					digit_sel <= "000";
					next_sel <= "000";
					digitout_reg <= "0000";
					anode_reg <= "11111111";

				elsif (clk'event and clk = '1') then
				
				    --check if overflow 
				    if(digit8_p & digit7_p & digit6_p & digit5_p  = "1111111111111111") THEN
                        digit_reg(19 downto 16) <= "0000";
                        digit_reg(23 downto 20) <= "1010";
                        digit_reg(27 downto 24) <= "1011";
                        digit_reg(31 downto 28) <= "0000"; 
                        if((digit3_p = "1111") OR (digit2_p = "1111") OR (digit1_p  = "1111")) THEN
                            digit_reg(3 downto 0) <= "0000";
                            digit_reg(7 downto 4) <= "1010";
                            digit_reg(11 downto 8) <= "1011";
                            digit_reg(15 downto 12) <= "0000";  
                        end if;
                        
                    elsif((digit3_p = "1111") OR (digit2_p = "1111") OR (digit1_p  = "1111")) THEN
                        digit_reg(3 downto 0) <= "0000";
                        digit_reg(7 downto 4) <= "1010";
                        digit_reg(11 downto 8) <= "1011";
                        digit_reg(15 downto 12) <= "0000"; 
                    
                    else					
					--latch digits into register on clock edge
					digit_reg(3 downto 0) <= digit1_p;
					digit_reg(7 downto 4) <= digit2_p;
					digit_reg(11 downto 8) <= digit3_p;
					digit_reg(15 downto 12) <= digit4_p;
					digit_reg(19 downto 16) <= digit5_p;
					digit_reg(23 downto 20) <= digit6_p;
					digit_reg(27 downto 24) <= digit7_p;
					digit_reg(31 downto 28) <= digit8_p;
					
					end if;
										                    
                    digit_sel <= next_sel;
                    
                    if(invert <= '0') then
                
                        case digit_sel is
                        
                            when "000" =>
                                anode_reg <= "11111110";	
                                digitout_reg <= digit_reg(3 downto 0);
                                next_sel <= "001";
                                cathode_p(7) <= '1';
                                
                            when "001" =>
                                anode_reg <= "11111101";	
                                digitout_reg <= digit_reg(7 downto 4);
                                digit_sel <= "010";
                                cathode_p(7) <= '1';
                                
                            when "010" =>
                                anode_reg <= "11111011";	
                                digitout_reg <= digit_reg(11 downto 8);
                                next_sel <= "011";
                                cathode_p(7) <= '0';
                                
                            when "011" =>
                                anode_reg <= "11110111";	
                                digitout_reg <= digit_reg(15 downto 12);
                                next_sel <= "100";
                                cathode_p(7) <= '1';
                                
                            when "100" =>
                                anode_reg <= "11101111";	
                                digitout_reg <= digit_reg(19 downto 16);
                                next_sel <= "101";
                                cathode_p(7) <= '1';
                                
                            when "101" =>
                                anode_reg <= "11011111";	
                                digitout_reg <= digit_reg(23 downto 20);
                                next_sel <= "110";
                                cathode_p(7) <= '1';
                                
                            when "110" =>
                                anode_reg <= "10111111";	
                                digitout_reg <= digit_reg(27 downto 24);
                                next_sel <= "111";
                                cathode_p(7) <= '0';
                                
                            when "111" =>
                                anode_reg <= "01111111";	
                                digitout_reg <= digit_reg(31 downto 28);
                                next_sel <= "000";
                                cathode_p(7) <= '1';
                                
                            when others =>
                                anode_reg <= "11111111";	
                                digitout_reg <= "0000";
                                next_sel <= "000";
                                cathode_p(7) <= '0';
                            
                        end case;
                    else
                        case digit_sel is
                                            
                            when "000" =>
                                anode_reg <= "11110111";    
                                digitout_reg <= digit_reg(3 downto 0);
                                next_sel <= "001";
                                cathode_p(7) <= '1';
                                
                            when "001" =>
                                anode_reg <= "11111011";    
                                digitout_reg <= digit_reg(7 downto 4);
                                digit_sel <= "010";
                                cathode_p(7) <= '0';
                                
                            when "010" =>
                                anode_reg <= "11111101";    
                                digitout_reg <= digit_reg(11 downto 8);
                                next_sel <= "011";
                                cathode_p(7) <= '1';
                                
                            when "011" =>
                                anode_reg <= "11111110";    
                                digitout_reg <= digit_reg(15 downto 12);
                                next_sel <= "100";
                                cathode_p(7) <= '1';
                                
                            when "100" =>
                                anode_reg <= "01111111";    
                                digitout_reg <= digit_reg(19 downto 16);
                                next_sel <= "101";
                                cathode_p(7) <= '1';
                                
                            when "101" =>
                                anode_reg <= "10111111";    
                                digitout_reg <= digit_reg(23 downto 20);
                                next_sel <= "110";
                                cathode_p(7) <= '0';
                                
                            when "110" =>
                                anode_reg <= "11011111";    
                                digitout_reg <= digit_reg(27 downto 24);
                                next_sel <= "111";
                                cathode_p(7) <= '1';
                                
                            when "111" =>
                                anode_reg <= "11101111";    
                                digitout_reg <= digit_reg(31 downto 28);
                                next_sel <= "000";
                                cathode_p(7) <= '1';
                                
                            when others =>
                                anode_reg <= "11111111";    
                                digitout_reg <= "0000";
                                next_sel <= "000";
                                cathode_p(7) <= '0';
                            
                        end case;
                    end if;
				end if;
			end process;
				
        process( invert, digitout_reg)
        begin
        --Connect the Cathode values
        if(invert = '0') then
            case digitout_reg is
                when "0000" => cathode_p(6 downto 0) <= "1000000";     -- 0 
                when "0001" => cathode_p(6 downto 0) <= "1111001";      -- 1
                when "0010" => cathode_p(6 downto 0) <= "0100100";      -- 2
                when "0011" => cathode_p(6 downto 0) <= "0110000";      -- 3
                when "0100" => cathode_p(6 downto 0) <= "0011001";      -- 4
                when "0101" => cathode_p(6 downto 0) <= "0010010";      -- 5
                when "0110" => cathode_p(6 downto 0) <= "0000010";      -- 6
                when "0111" => cathode_p(6 downto 0) <= "1111000";      -- 7
                when "1000" => cathode_p(6 downto 0) <= "0000000";      -- 8
                when "1001" => cathode_p(6 downto 0) <= "0011000";      -- 9
                when "1010" => cathode_p(6 downto 0) <= "1000111";      -- A let give L
                when "1011" => cathode_p(6 downto 0) <= "0001110";      -- B let give F
                when "1100" => cathode_p(6 downto 0) <= "1111111";      -- C
                when "1101" => cathode_p(6 downto 0) <= "1111111";      -- D
                when "1110" => cathode_p(6 downto 0) <= "1111111";      -- E
                when "1111" => cathode_p(6 downto 0) <= "0111111";      -- F
      
            end case;
        else   
            case digitout_reg is
                when "0000" => cathode_p(6 downto 0) <= "1000000";     -- 0 
                when "0001" => cathode_p(6 downto 0) <= "1001111";      -- 1
                when "0010" => cathode_p(6 downto 0) <= "0100100";      -- 2
                when "0011" => cathode_p(6 downto 0) <= "0000110";      -- 3
                when "0100" => cathode_p(6 downto 0) <= "0001011";      -- 4
                when "0101" => cathode_p(6 downto 0) <= "0010010";      -- 5
                when "0110" => cathode_p(6 downto 0) <= "0010000";      -- 6
                when "0111" => cathode_p(6 downto 0) <= "1000111";      -- 7
                when "1000" => cathode_p(6 downto 0) <= "0000000";      -- 8
                when "1001" => cathode_p(6 downto 0) <= "0000011";      -- 9
                when "1010" => cathode_p(6 downto 0) <= "1111000";      -- A let give L
                when "1011" => cathode_p(6 downto 0) <= "0110001";      -- B let give F
                when "1100" => cathode_p(6 downto 0) <= "1111111";      -- C
                when "1101" => cathode_p(6 downto 0) <= "1111111";      -- D
                when "1110" => cathode_p(6 downto 0) <= "1111111";      -- E
                when "1111" => cathode_p(6 downto 0) <= "0111111";      -- F

            end case;            
       end if;
    end process;
         --Connect the Anode values
		 anode_p <= anode_reg;

end behavioural;